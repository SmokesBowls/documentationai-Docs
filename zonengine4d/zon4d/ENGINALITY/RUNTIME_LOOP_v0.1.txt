# RUNTIME LOOP v0.1

**Status:** Draft → locks when first compliant implementation passes validation
**Domain:** EngAIn / Enginality
**Dependencies:** ENGINEBILITY_CORE_CONTRACT_v0.1, ZON4D Temporal Law, AP Rule Engine
**Role:** Defines the atomic execution cycle that enforces Enginebility Contract at kernel clock.

This is **the implementation blueprint** for any compliant Enginality runtime.

---

# OVERVIEW

The Runtime Loop is a **deterministic 11-step pipeline** executed once per Engine Tick.

**Core Principle:**
> The Loop exists only to enforce the Enginebility Contract. Any step that cannot guarantee contract compliance MUST abort the Tick and revert to last known-good Snapshot.

**Tick Rate:**
- Target: 60Hz (16.67ms per Tick) for real-time performance
- Guarantee: Deterministic output regardless of tick duration
- Degradation: If Tick exceeds budget → temporal fence + alert (never skip validation)

---

# THE 11-STEP PIPELINE

## STEP 1: TICK INITIALIZATION

**Purpose:** Prepare clean execution context for this Tick.

**Actions:**
1. Increment Tick counter (monotonic, never reset)
2. Capture wall-clock timestamp (for logging only, NOT used in temporal logic)
3. Load current canonical Snapshot reference
4. Initialize empty Delta queue
5. Reset conflict detection buffer
6. Clear previous Tick's alert log

**Enforces:**
- G1 (Deterministic Mutation) - Clean slate per Tick
- G4 (Zero Ambiguity) - Explicit state boundaries

**Breach Conditions:**
- Tick counter overflow → CRITICAL alert, halt engine
- Cannot load canonical Snapshot → revert to last immutable anchor

**Output:**
- Initialized Tick context ready for Delta ingestion

---

## STEP 2: DELTA QUEUE INGESTION

**Purpose:** Collect all pending mutations from all sources.

**Input Sources:**
1. User actions (input events, UI commands)
2. AI agent decisions (MrLore, ClutterBot, Trae outputs)
3. AP rule-generated Deltas (conditional triggers)
4. Temporal system (scheduled events, time-curve evaluations)
5. External integrations (network, file I/O)

**Actions:**
1. Call `ingest(delta)` for each pending Delta
2. Validate Delta structure (type, fields, temporal metadata)
3. Reject malformed Deltas immediately (R1 - Non-Canonical Writes)
4. Queue valid Deltas for temporal ordering

**Enforces:**
- P1 (Real-Time Delta Ingestion) - No Delta sits unprocessed
- R1 (Non-Canonical Writes) - Structural validation

**Breach Conditions:**
- Unknown Delta type → reject, log, continue
- Missing temporal metadata → reject (R4 - Ambiguous Temporal Scope)
- Queue overflow → temporal fence, alert operator

**Output:**
- Populated Delta queue (unsorted)
- Rejection log for malformed Deltas

---

## STEP 3: TEMPORAL ORDERING

**Purpose:** Sort Deltas into deterministic execution order.

**Algorithm:**
1. Primary sort: temporal index (t-coordinate in ZON4D)
2. Secondary sort: causality chain (parent → child dependencies)
3. Tertiary sort: Delta source ID (deterministic tiebreaker)

**Critical Rules:**
- Deltas targeting same temporal index MUST have explicit ordering via causality chain
- If ordering ambiguous → flag as conflict for Step 4
- Never use wall-clock time for ordering (violates G1)

**Enforces:**
- G1 (Deterministic Mutation) - Same Deltas → same order
- Section 31 (Temporal Syncpoints) - Anchor-based ordering

**Breach Conditions:**
- Circular causality chain → reject entire chain (R2 - Unanchored Mutations)
- Delta references future Snapshot not yet created → branch or reject

**Output:**
- Ordered Delta sequence ready for conflict detection
- Flagged ambiguous orderings

---

## STEP 4: CONFLICT SET DETECTION

**Purpose:** Identify Deltas that mutate overlapping canonical state.

**Conflict Definition:**
Two Deltas conflict if they:
1. Target the same ZON4D entity/field
2. Have overlapping temporal scope
3. Propose incompatible values

**Actions:**
1. Build conflict matrix (Delta × Delta × Field)
2. For each conflict set:
   - Check if deterministic merge policy exists
   - If yes → apply merge, mark resolved
   - If no → flag for AP arbitration
3. Tag conflicting Deltas with conflict set ID

**Enforces:**
- P2 (Concurrency Support) - Multi-source mutations handled
- Section 24 (Oracle Law) - Conflict arbitration preparation

**Breach Conditions:**
- Merge policy produces invalid state → reject merge, escalate to AP
- Conflict set too large (>threshold) → temporal fence, manual review

**Output:**
- Resolved conflicts (merged Deltas)
- Unresolved conflicts (flagged for Step 5)

---

## STEP 5: AP PREFLIGHT

**Purpose:** Validate Deltas against AP rules BEFORE mutation.

**Actions:**
1. For each Delta (or merged Delta):
   - Load applicable AP Rule Set for target entity/field
   - Evaluate: ACCEPT / REJECT / ARBITRATE
2. ACCEPT → continue to Step 6
3. REJECT → discard Delta, log reason, alert originator
4. ARBITRATE → invoke AP arbitration protocol:
   - Present conflict context to AP Kernel
   - Wait for arbitration result (blocking or async)
   - Apply arbitrated resolution

**Enforces:**
- G3 (AP Compliance) - No commits without rule validation
- R3 (AP Contradictions) - Explicit arbitration path
- Section 20 (AP Hooks on ZON4D) - Rule evaluation points

**Breach Conditions:**
- AP Rule Set unavailable → temporal fence, cannot proceed
- Arbitration timeout → reject Delta, alert
- AP verdict contradicts ZON4D typing → CRITICAL breach, halt

**Output:**
- ACCEPTED Deltas ready for application
- REJECTED Deltas logged
- ARBITRATED Deltas resolved and ready

---

## STEP 6: DELTA APPLICATION

**Purpose:** Mutate the canonical Snapshot.

**Actions:**
1. Clone current canonical Snapshot (copy-on-write)
2. For each ACCEPTED Delta (in temporal order):
   - Apply mutation to cloned Snapshot
   - Log: old value, new value, Delta ID, causality chain
   - Compute inverse Delta for reversibility (G2)
3. Validate resulting Snapshot:
   - Check ZON4D type constraints
   - Verify no orphaned references
   - Confirm all mandatory fields present

**Enforces:**
- G1 (Deterministic Mutation) - Ordered application
- G2 (Reversible Edits) - Inverse Deltas computed
- R1 (Non-Canonical Writes) - Type validation post-mutation

**Breach Conditions:**
- Mutation produces invalid ZON4D state → rollback to pre-Tick Snapshot
- Inverse Delta cannot be computed → reject mutation (G2 violation)

**Output:**
- New candidate Snapshot (not yet canonical)
- Mutation log with inverse Deltas
- Validation status

---

## STEP 7: SNAPSHOT HYDRATION

**Purpose:** Populate all execution domains from the new Snapshot.

**Domains:**
1. **Narrative** - dialogue state, story flags, character relationships
2. **Spatial** - 3D positions, collision data, navigation graphs
3. **Audio/Visual** - sound state, animation curves, camera rules
4. **AP Rule Domain** - active constraints, trigger conditions

**Actions:**
1. For each domain:
   - Extract relevant fields from Snapshot
   - Hydrate domain-specific structures
   - Validate domain consistency
2. If any domain fails hydration:
   - Log failure reason
   - Check degradation policy:
     - STRICT: rollback entire Snapshot (P4)
     - GRACEFUL: disable failed domain, continue with warnings

**Enforces:**
- P4 (Cross-Domain Hydration) - One Snapshot → all domains
- G4 (Zero Ambiguity) - State vs Memory separation maintained

**Breach Conditions:**
- Critical domain (e.g., Spatial) fails → rollback
- Non-critical domain fails → degrade, alert
- Hydration produces inconsistent cross-domain state → rollback

**Output:**
- Fully hydrated multi-domain state
- Degradation flags (if any)
- Hydration success status

---

## STEP 8: AP FINALIZATION

**Purpose:** Post-commit rule validation.

**Why Needed:**
Preflight (Step 5) validates individual Deltas. Finalization validates the **combined result** after all mutations applied.

**Actions:**
1. Load AP Rule Set for entire world state
2. Evaluate global constraints (e.g., "no player in two locations", "narrative flags consistent")
3. Verdict:
   - ACCEPT → proceed to Step 9
   - REJECT → rollback to pre-Tick Snapshot, alert
   - ARBITRATE → invoke AP, apply resolution, re-validate

**Enforces:**
- G3 (AP Compliance) - Global state validation
- Section 24 (Oracle Law) - Kernel arbitration

**Breach Conditions:**
- Global constraint violated → rollback, log violation
- AP arbitration produces new violation → CRITICAL, halt
- Re-validation after arbitration fails → CRITICAL, halt

**Output:**
- Finalized AP-compliant Snapshot
- Global constraint validation status

---

## STEP 9: ANCHOR UPDATE PROTOCOL

**Purpose:** Mark the new Snapshot as canonical and update anchors.

**Actions:**
1. Compute Snapshot hash (Section 32 - HASH32 Spec)
2. Compare to previous Snapshot hash (Section 33 - Snapshot Diff)
3. Update Timeline:
   - Append new Snapshot to canonical Timeline
   - Link to previous Snapshot via hash chain
4. Anchor Classification:
   - **Soft Anchor**: Normal Tick, can be retconned later
   - **Hard Anchor**: Explicitly marked immutable checkpoint
   - **Immutable Anchor**: Critical savepoint, never modified
5. Prune old Snapshots per retention policy (keep anchors, discard intermediates)

**Enforces:**
- Section 31 (Temporal Syncpoints) - Hash-verified anchors
- Section 32 (Canonical Hashing) - Deterministic hash computation
- P3 (Temporal Fences) - Anchor mutability rules

**Breach Conditions:**
- Hash collision detected → CRITICAL, investigate data corruption
- Cannot link to previous Snapshot → Timeline discontinuity, halt
- Anchor promotion fails validation → revert to soft anchor

**Output:**
- New canonical Snapshot with hash anchor
- Updated Timeline reference
- Pruned historical Snapshots (if applicable)

---

## STEP 10: CROSS-DOMAIN EXPOSURE

**Purpose:** Make the new canonical state available to all subsystems.

**Subsystems:**
1. **Renderer** - 3D scene, camera, lighting
2. **Audio Engine** - sound state, music transitions
3. **Animation System** - character poses, facial visemes
4. **Dialogue Engine** - active speaker, emotion curves
5. **AI Agents** - world state for decision-making
6. **Network Layer** - state sync for multiplayer (future)

**Actions:**
1. For each subsystem:
   - Expose relevant domain data from hydrated Snapshot (Step 7)
   - Signal state update event
   - Provide read-only access (no direct mutation allowed)
2. Log exposure timestamps for debugging

**Enforces:**
- G4 (Zero Ambiguity) - Subsystems read State, not History or Memory
- P4 (Cross-Domain Hydration) - All domains receive consistent state

**Breach Conditions:**
- Subsystem attempts direct state mutation → block, alert
- Exposure fails for critical subsystem (Renderer) → degrade, temporal fence

**Output:**
- State exposed to all subsystems
- Subsystem acknowledgment signals
- Exposure success log

---

## STEP 11: PERFORMANCE PASS SCHEDULING

**Purpose:** Queue rendering, audio, and animation tasks based on new state.

**Performance Domains:**
1. **Visual** - render frames, camera moves
2. **Audio** - play sounds, update envelopes (Section 19)
3. **Animation** - apply curves, blend poses
4. **Dialogue** - trigger voice lines, update visemes (Section 18)
5. **SceneTrack** - manage multi-track performance (Section 22)

**Actions:**
1. For each domain:
   - Compare new state to previous state (delta detection)
   - Queue only changed elements (optimization)
   - Respect temporal curves (ZON4D time → performance time)
2. Schedule next Tick:
   - If real-time mode: schedule at target Hz (60Hz)
   - If step mode: wait for manual trigger
   - If overloaded: insert temporal fence, skip frame if needed

**Enforces:**
- Section 13 (Dialogue Intensity Tracks) - Emotion-driven performance
- Section 19 (Audio Envelopes) - Sound curve evaluation
- Section 22 (SceneTrack) - Multi-track synchronization

**Breach Conditions:**
- Scheduling budget exceeded → temporal fence, drop low-priority tasks
- Performance queue overflow → alert, degrade quality

**Output:**
- Scheduled performance tasks
- Next Tick scheduled
- **TICK COMPLETE**

---

# TICK COMPLETE

At this point, the Engine has:
1. ✓ Ingested all pending Deltas
2. ✓ Ordered them deterministically
3. ✓ Resolved conflicts
4. ✓ Validated with AP (preflight + finalization)
5. ✓ Mutated the canonical Snapshot
6. ✓ Hydrated all domains
7. ✓ Anchored the new state
8. ✓ Exposed state to subsystems
9. ✓ Scheduled performance tasks

**The Loop repeats.**

---

# BREACH HANDLING ACROSS STEPS

If **any step** detects a contract violation:

1. **HALT** the current Tick (do not proceed to next step)
2. **EMIT** CRITICAL alert to Kernel/ZWAlerts
3. **PERSIST** repro data:
   - Current Snapshot ID
   - Pending Delta queue
   - AP verdicts
   - Step where breach occurred
4. **REVERT** to last known-good Snapshot:
   - Find most recent Immutable Anchor
   - Restore state from anchor
   - Discard all Ticks since anchor
5. **ALERT** operator for manual intervention

**Silent failures are breaches.** All errors must be logged and handled explicitly.

---

# PERFORMANCE GUARANTEES

## Determinism (G1)
Given identical inputs at Step 1, Steps 2-11 produce identical outputs.

## Reversibility (G2)
After Step 6, inverse Deltas exist to undo mutations.

## AP Compliance (G3)
Steps 5 + 8 ensure no non-compliant state ever becomes canonical.

## Temporal Fences (P3)
If any step exceeds time budget:
- Insert explicit fence marker in Timeline
- Alert subsystems to degraded mode
- Continue with best-effort (never skip validation)

---

# INTEGRATION POINTS

**With ZON4D Temporal Law:**
- Step 3: Temporal Ordering (Section 31 - Syncpoints)
- Step 9: Anchor Update (Section 32 - Hashing)
- Section 34: Snapshot Consolidation (post-Tick merge protocol)

**With AP Rule Engine:**
- Step 5: Preflight validation
- Step 8: Finalization validation
- Section 24: Oracle Law arbitration hooks

**With Performer Engine:**
- Step 11: SceneTrack scheduling (Section 22)
- Dialogue Tracks (Section 13)
- Audio Envelopes (Section 19)
- Visemes (Section 18)

---

# COMPLIANCE CRITERIA

A Runtime Loop implementation is **Enginal-compliant** if:

1. It executes all 11 steps in order
2. It enforces all Enginebility Contract clauses (G1-G4, P1-P4, R1-R4)
3. It handles breaches per Section 5 of the Contract
4. It produces deterministic output given deterministic input
5. It logs all decisions for replay/debugging

**Non-compliant implementations** may produce output but are not Enginality runtimes.

---

# NEXT STEPS FOR IMPLEMENTATION

1. **Python Prototype** - Implement loop in `core/enginality/runtime_loop.py`
2. **Godot Integration** - GDScript runtime in `godot/addons/engain/enginality/`
3. **Compliance Tests** - Generate test suite validating all 11 steps
4. **Breach Simulation** - Test failure modes (malformed Deltas, AP rejections, hash collisions)
5. **Performance Profiling** - Measure step timing, optimize bottlenecks

---

# Loop Ends
