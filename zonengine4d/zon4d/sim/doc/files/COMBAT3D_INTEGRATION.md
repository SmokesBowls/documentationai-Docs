# Combat3D Integration Guide

## Architecture Overview

Combat3D follows the canonical EngAIn 3-layer pattern:

```
┌─────────────────────────────────────────┐
│         ENGINE DELTA BUS                │
│  (behavior3d, navigation3d, spatial3d)  │
└─────────────────┬───────────────────────┘
                  │
         ┌────────▼─────────┐
         │  Combat3DAdapter  │  ← Layer 3: Adapter
         │  - Delta queuing  │
         │  - Alert → Delta  │
         └────────┬──────────┘
                  │
         ┌────────▼─────────┐
         │   combat3d_mr    │  ← Layer 1: Pure MR Kernel
         │  - apply_damage  │
         │  - detect_death  │
         │  - alerts        │
         └──────────────────┘
```

## What Combat3D Does

**IN SCOPE (v0.1):**
- Apply damage to entities
- Detect death (health <= 0)
- Detect low health (health <= 25%)
- Emit alerts to behavior/navigation systems

**OUT OF SCOPE (for now):**
- Hit detection (use Spatial3D collision)
- Projectiles (future: Projectile3D subsystem)
- Status effects (future: StatusEffect3D)
- Weapons/items (future: Equipment3D)
- Stagger/knockback (future: add to Combat3D)

## Data Flow

### 1. Damage Application
```python
# Behavior3D decides to attack
behavior.attack("player", "orc_1")
  ↓
# Behavior3D emits damage delta
("combat3d/apply_damage", {
    "source": "player",
    "target": "orc_1", 
    "amount": 45.0
})
  ↓
# Combat3DAdapter queues event
combat.handle_delta(...)
  ↓
# Engine tick processes
deltas = combat.tick()
  ↓
# Combat3D emits alerts
[("behavior3d/set_flag", {"entity": "orc_1", "flag": "low_health"})]
```

### 2. Death Propagation
```python
# Lethal damage applied
("combat3d/apply_damage", {"amount": 100.0, "target": "enemy"})
  ↓
# Combat3D detects death
entity.health = 0.0
entity.alive = False
  ↓
# Generates multiple alert deltas
[
  ("behavior3d/set_flag", {"entity": "enemy", "flag": "dead"}),
  ("navigation3d/disable", {"entity": "enemy"})
]
  ↓
# Other systems respond
- Navigation stops pathfinding
- Behavior enters death state
- Spatial triggers ragdoll (future)
```

## Integration Points

### With Behavior3D
```python
# Behavior decides to attack (simplified)
if can_attack(entity, target):
    emit_delta("combat3d/apply_damage", {
        "source": entity.id,
        "target": target.id,
        "amount": entity.attack_power
    })

# Behavior reacts to combat alerts
def on_delta(delta_type, payload):
    if delta_type == "behavior3d/set_flag":
        if payload["flag"] == "low_health":
            enter_flee_state(payload["entity"])
        elif payload["flag"] == "dead":
            enter_death_animation(payload["entity"])
```

### With Navigation3D
```python
# Navigation receives disable on death
def on_delta(delta_type, payload):
    if delta_type == "navigation3d/disable":
        entity_id = payload["entity"]
        disable_pathfinding(entity_id)
        clear_movement_target(entity_id)
```

### With Spatial3D (future)
```python
# Hit detection happens in Spatial3D
if collision_detected(attack_box, target_collider):
    emit_delta("combat3d/apply_damage", {
        "source": attacker_id,
        "target": target_id,
        "amount": weapon_damage
    })
```

## Usage Example

```python
# Initialize
combat = Combat3DAdapter()

# Register entities (called by entity spawner)
combat.register_entity("player", health=100.0, max_health=100.0)
combat.register_entity("orc_1", health=80.0, max_health=80.0)

# Handle incoming deltas (called by delta bus)
combat.handle_delta("combat3d/apply_damage", {
    "source": "player",
    "target": "orc_1",
    "amount": 45.0
})

# Process tick (called by engine loop)
outgoing_deltas = combat.tick()

# Propagate alerts to other subsystems
for delta_type, payload in outgoing_deltas:
    delta_bus.emit(delta_type, payload)

# Query state (optional)
health, max_health = combat.get_entity_health("orc_1")
is_alive = combat.is_alive("orc_1")
```

## API Reference

### Combat3DAdapter

#### `register_entity(entity_id: str, health: float, max_health: float)`
Add entity to combat tracking. Call when spawning.

#### `unregister_entity(entity_id: str)`
Remove entity from combat. Call when despawning.

#### `handle_delta(delta_type: str, payload: Dict[str, Any])`
Queue incoming combat delta. Supported types:
- `"combat3d/apply_damage"` - Apply damage to target

#### `tick() -> List[Tuple[str, Dict[str, Any]]]`
Process queued events and return alert deltas.

#### `get_entity_health(entity_id: str) -> Tuple[float, float]`
Query current (health, max_health).

#### `is_alive(entity_id: str) -> bool`
Check if entity is alive.

## Alert Types

### Generated by Combat3D:

**`("behavior3d/set_flag", {"entity": str, "flag": "dead"})`**
- Triggered when entity health reaches 0
- Behavior should enter death state

**`("behavior3d/set_flag", {"entity": str, "flag": "low_health"})`**
- Triggered when health drops below 25%
- Behavior can flee, heal, call for help

**`("navigation3d/disable", {"entity": str})`**
- Triggered on death
- Navigation should stop pathfinding

## Testing

Run test suite:
```bash
python test_combat3d.py
```

All tests should pass, demonstrating:
- Basic damage application
- Death detection
- Low health alerts
- Multiple simultaneous events
- Dead entity immunity

## Next Steps

Choose next Combat3D expansion:
- **A)** Hit detection (Spatial3D overlap)
- **B)** Stagger/knockback (impulse deltas)
- **C)** Behavior rules (flee, aggression)
- **D)** Death handling (Navigation integration)
- **E)** Godot bridge (`combat.gd`)

---

**Status:** ✅ Core Combat3D complete and tested  
**Dependencies:** None (pure Python)  
**Compatible with:** Spatial3D, Perception3D, Navigation3D, Behavior3D
